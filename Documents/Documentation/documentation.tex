\documentclass[11pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{last page}
\usepackage{fancyhdr}
\usepackage{enumitem}

\title{Todolister - dokumentace}
\date{ZS 2016/2017}
\author{Václav Balcar, 2. ročník, 31. studijní skupina}

\renewcommand*\contentsname{Obsah}

\geometry{a4paper, total={190mm, 277mm}, left=20mm, right=20mm, top=20mm, bottom=20mm}
%\setlength{\parindent}{0mm}

\fancyhf{}
\lhead{Dokumentace zápočtového programu z Programování v C++}
\rhead{Todolister}
\rfoot{\thepage}
\pagestyle{fancy}

\begin{document}
\maketitle
\pagenumbering{gobble}
\newpage
\pagenumbering{arabic}
\tableofcontents
\newpage


\section{Uživatelská dokumentace}
\subsection{O programu}
\paragraph{Todolister} je program na zpracovávání dat obsahujících objekty mající informaci o čase, ve kterém se vyskytují (konají, začínají atp.).\\
Takovým objektům říkejme individua z časových organizérů nebo zkráceně "TOI" z angl. "time organizer individual".\\
Množině obsahující libovolné množství TOI říkejme "organizéry času" nebo zkráceně "TO" z angl. "time organizer".\\
Zkratky TOI a TO mohou reprezentovat i množné číslo zkráceného tvaru.\\
Program nemá GUI a ovládá se pomocí argumentů.

\paragraph{Zpracovávaná data} lze charakterizovat pomocí následujících veličin:
\subparagraph{Struktura TOI} je řetězec, ve kterém každý znak reprezentuje jednu položku v TOI a pořadí znaků odpovídá pořadí těchto položek v TOI.
\subparagraph{Znaky, jenž lze použít a jejich význam}
\begin{enumerate}[leftmargin=5mm]
\item U = unikátní identifikátor
\item C = datum a čas vytvoření události/položky todolistu
\item S = datum a čas začátku události
\item E = datum a čas konce události
\item D = datum a čas deadliny položky todolistu
\item N = pojmenování události/položky todolistu
\end{enumerate}
\subparagraph{Typ TOI} je typ TOI, jaký TO obsahuje. Implemetované typy TOI jsou "event" a "todo". Event může obsahovat položky reprezentované znaky U,C,S,E,N a todo může obsahovat položky reprezentované znaky U,C,D,N.
\subparagraph{Oddělovač argumentů TOI} je retězec obsahující všechny možné jednoznakové oddělovače argumentů TOI. V případě zápisu výstupu 
jsou všechny argumenty TOI oddělena celým daným řetězcem.
\subparagraph{Rozložení dat v souboru} reprezentuje způsob, jakým jsou data uvnitř souboru uspořádána. Některá rozložení potřebují ještě dodatečné informace o oddělovači TOI a o pořadí a typech informací, jaké jsou v souboru s TO uloženy.\\
Implementovaná rozložení dat v souboru jsou "ical" a "table", kde table reprezentuje tabulkové rozložení dat v souboru, kdy jeden řádek představuje jedno TOI, kdy jednotlivé položky TOI jsou oddělené podle informací v oddělovači a "ical" reprezentuje rozložení dat dle formátu iCalendar.
\subparagraph{Formát dat v souboru} určuje formát časových dat na vstupu/výstupu, tudíž způsob, jakým se mají taková data parsovat a způsob, jakým se mají tisknout.\\
Implementované formáty jsou "cs-cz" (český long date-time formát), "en-us" (americký long date-time formát) a "ical" (date-time formát používaný ve formátu iCalendar).

\paragraph{Argumenty} programu jsou posloupnost slov reprezentovaná právě tím způsobem, jakým jsou reprezentovány argumenty předávané programům přes příkazovou řádku při spouštění. Tato slova lze rozdělit na řídící a datová, kdy datová slova reprezentují argumenty posledního předcházejícího řídícího slova.\\
Každé řídící slovo má svojí reprezentaci - Unixovou a HR (= human-readable). Řídící slova jsou dále uvedena ve své HR reprezentaci, unixová reprezentace k jednotlivým HR reprezentacím je uvedena dále v samostatné sekci.\\
Každá reprezentace každého řídícího slova je case-insenzitivní, datová slova jsou case-senzitivní.\\
Řídící slovo bez argumentů nazvěme klíčové slovo.\\
Nazvěme řídící slovo následované svými argumenty souslovím. Pak sousloví je uspořádaná dvojice (řídící slovo, argumenty řídícího slova).\\
Nazvěme posloupnost sousloví větou a posloupnost vět atomickým souvětím. Pak každé atomické souvětí je souvětí a libovolná posloupnost souvětí je opět souvětí.\\
Nechť seznam je souvětí obsahující prvky stejné třídy.\\
Nechť s-dvojice (= sémanticky jednoznačná dvojice) je uspořádaná dvojice (řídící slovo, souvětí), sousloví nebo uspořádaná dvojice (sousloví, souvětí).\\
Pak validní argumenty programu jsou buď posloupnost s-dvojic, nebo klíčové slovo.\\
Implementované s-dvojice a k nim potřebná souvětí jsou uvedené dále.
\subparagraph{Soubor} je s-dvojice ("file", jméno souboru)
\subparagraph{Typ} je s-dvojice ("containing", typ TOI)
\subparagraph{Oddělovače} jsou s-dvojice ("delimiters", oddělovač argumentů v TOI)
\subparagraph{Obsah} je s-dvojice ("select", struktura TOI)
\subparagraph{Layout} je s-dvojice ("layout", rozložení dat v souboru)
\subparagraph{Formát} je s-dvojice ("format", formát dat v souboru)
\subparagraph{PopisIO} je souvětí {typ, oddělovače, obsah, layout, formát}
\subparagraph{IO} je souvětí {soubor, popisIO} reprezentující vstup/výstup ze/do souboru nebo souvětí popisIO reprezentující vstup/výstup na standardní vstup/výstup
\subparagraph{Registrace TO} je s-dvojice ("register", (jméno, IO)). Registrace vrací zaregistrované IO vložitelné do jakéhokoliv seznamu IO.
\subparagraph{Načtení zaregistrovaného TO} je s-dvojice ("load", jméno zaregistrovaného TO). Načtení zaregistrovaného TO vrací zaregistrované IO vložitelné do jakéhokoliv seznamu IO.
\subparagraph{Vstup} je s-dvojice ("from", seznam IO)
\subparagraph{Výstup} je s-dvojice ("to", IO)
\subparagraph{Operace} je s-dvojice (název operace, argumenty operace)
\subparagraph{Provedení operace} je s-dvojice ("do", operace)

\subsection{Implementované operace}
Implementované jsou následující operace:
\begin{enumerate}[leftmargin=5mm]
\item insert = s-dvojice ("insert", seznam IO). Postupně vloží všechna TO ze seznamu IO na konec aktuálního TO.
\item filter = s-dvojice ("filter", filtr). Z aktuálního TO vytvoří TO obsahující TOI splňující filtr.
\item remove = s-dvojice ("remove", filtr). Z aktuálního TO vytvoří TO obsahující TOI nesplňující filtr.
\item sort = s-dvojice ("sort", ASC/DESC). Setřídí aktuální TO vzestupně (<= ASC) nebo sestupně (<= DESC).
\item merge = s-dvojice ("merge", seznam IO). Provede nejprve ("merge", seznam IO) a následně ("sort", DESC).
\end{enumerate}
\subsubsection{Implementované filtry}
Implementované jsou následující filtry:
\begin{enumerate}[leftmargin=5mm]
\item current = posloupnost argumentů ("current", "year"/"month"/"day"/"hour"/"minute"). Tento filtr splňují TOI s časem odpovídající aktuálnímu roku/měsíci/dni/hodině/minutě.
\item datetime = posloupnost argumentů ("datetime", "since"/"matches"/"until", datetime). Tento filtr splňují TOI s časem od/v/do času datetime, což je řetězec obsahující čas/datum/čas{vhodný oddělovač}datum v libovolném implementovaném formátu nebo řetězec now/today reprezentující aktuální čas/dnešní datum.
\item top = posloupnost argumentů ("top", n). Tento filtr splňuje prvních n TOI z aktuálního TO.
\end{enumerate}

\subsection{Zpracování argumentů}
Ze vstupu se načte TO, provede se na něm posloupnost operací přečtených z argumentů a výsledek je vypsán do výstupu.\\
Všechna IO ze seznamu IO ze vstupu zůstávají nezměněna. Obsahuje-li seznam IO ze vstupu více položek, jsou TO z těchto položek parsovány ve stejném pořadí, v jakém jsou uvedeny na vstupu a výsledně načtené TO bude sestávat ze za sebou poskládaných TO z jednotlivých IO právě v tom pořadí, v jakém byly parsovány. V tomto seznamu stačí uvést popisIO pouze u jednoho IO, přičemž první výskyt těchto informací je považován za výchozí a pokud u některého z IO explicitně chybí, je použita právě výchozí hodnota.\\
Operace jsou provedeny právě v tom pořadí, v jakém jsou přečteny z argumentů.\\ Vstupní IO může výt zároveň i výstupní.
\subsubsection{Jak předat programu argumenty}
Jsou tři možnosti:
\begin{enumerate}[leftmargin=5mm]
\item předat je programu standardním způsobem při spuštění přes příkazovou řádku
\item spustit program v interaktivním režimu tím, že je spuštěn bez argumentů. Argumenty jsou pak čteny ze standardního vstupu, kdy každá řádka je vyhodnocena jako samostatná posloupnost argumentů. Je-li zpracovávaná posloupnost pouze klíčové slovo "end" nebo "q", je interaktivní režim a s ním i celý program ukončen.
\item spustit skript. To lze provést spuštěním programu pouze s argumenty "skript 'cesta k souboru obsahujícímu skript'". Každý řádek skriptu je pak vyhodnocen jako samostatná posloupnost argumentů. Je-li řádek prázdný, je na výstup zapsán také prázdný řádek. Začíná-li řádek skriptu dvojicí znaků "**", je zbytek řádky vypsán na výstup jako nadpis (=> barevně a zdobně). Začíná-li řádek skriptu dvojicí znaků "//", je zbytek řádky vypsán na výstup jako komentář (=> barevně).
\end{enumerate}

\subsection{Funkce Todolisteru}
Todolister má například následující (i mnohé další) funkce:
\begin{enumerate}[leftmargin=5mm]
\item správa vícera souborů obsahujících TO
\item načítaní TO dle IO
\item přidávání/odebírání/filtrace TOI do/z TO
\item filtrování TOI z TO (horizontální filtrování)
\item filtrování informací z TOI v nějakém TO (vertikální filtrování)
\item třídění TO
\item slučování TO
\item slévání TO
\item ukládání výsledného TO dle IO
\item konverze vstupu dle IO výstupu
\end{enumerate}

\subsection{Unixová reprezentace odpovídající jednotlivým HR reprezentacím}
\begin{enumerate}[leftmargin=5mm]
\item "from" = "-i"
\item "file" = "-f"
\item "layout" = "-l"
\item "format" = "-m"
\item "containing" = "-t"
\item "delimiters" = "-c"
\item "select" = "-d"
\item "do" = "-p"
\item "to" = "-o"
\item "register" = "-r"
\item "load" = "-l"
\item "end" = "-q"
\item "q" = "-q"
\item "script" = "-s"
\end{enumerate}

\subsection{Jak funguje registrace souboru}
Informace o zaregistrovaném souboru se uloží do souboru 'nastavený název pro zaregistrovaný souboru'.conf. Tyto informace přesně odpovídají zaregistrovanému IO. Při načtení zaregistrovaného souboru se tyto informace z tohoto souboru opět přečtou, proto není nutné je již zadat.
\newpage

\section{Programátorská dokumentace}
\subsection{O Todolisteru}
Celý Todolister je postaven na factory patternu. Chování programu je vysvětleno v uživatelské dokumentaci, zde pouze nastíním programátorské řešení některých problémů.
\subsection{Význam jednotlivých složek tříd - filtrů}
\subsubsection{DateTime}
Datetime obsahuje všechny třídy týkající se času obecně.
\subsubsection{Exception}
Exception obsahuje všechny výjimky, které Todolister hází. Každá taková výjimka je  buď TodolisterException nebo její potomek.
\subsubsection{TimeOrganizer}
TimeOrganizer obsahuje implementaci obecného TO, implementace operací nad prvky z TO, implementace typů TOI a implementace filtrů.\\
TO je vnitřně implementovaný jako vector unikátních ukazatelů na TOI.
\subsubsection{DataDescription}
DataDescription obsahuje implentace layoutů a formátů.

\subsection{Význam ostatních tříd}
\subsubsection{ArgTranslator}
Třída řešící předzpracování argumentů - převedení velkých písmen na malá a následný překlad z HR reprezentace do unixové reprezentace, je-li tomu třeba.
\subsubsection{ArgumentsProcessor}
Třída přerozdělující argumenty mezi InputParser, OutputPrinter a TOOGeneralParser. Také poskytuje přístup k výsledkům parsování argumentů.
\subsubsection{InputParser}
Třída parsující vstup dle instrukcí z argumentů.
\subsubsection{OutputPrinter}
Třída tiskající výstup dle instrukcí z argumentů.
\subsubsection{TOOGeneralParser}
Třída přerozdělující argumenty mezi parsery konkrétních implementací operací nad prvky z TO.
\subsection{Registry}
Pilíře programu jsou třídy registrů, které obsahují konkrétní implementace všeho potřebného.\\
Registry jsou implementovány jako hašovací tabulky, konkrétně jako příslušný typ "unorded$\_$map".
\begin{enumerate}[leftmargin=5mm]
\item TOIIORegister = registr implementací printerů a parserů typu TOI
\item LayoutFactoryRegister = registr implementací továren layoutů
\item FormatRegister = registr implementací formátů
\item FilterParserRegister = registr implementací parserů filtrů
\item TOOParserRegister = registr parserů implementací operací nad prvky z TO
\end{enumerate}
\subsection{Existující implementace abstraktních tříd}
Existující implementace abstraktních tříd lze vyčíst z uživatelské dokumentace a každé implementaci odpovídá nějaká třída, kterou lze nalézt v příslušné složce (filtru) v projektu.
\subsection{Jak rozšířit program o další implementce}
Stačí přidat instanci třídy implementace do příslušného registru.
K tomu je třeba vytvořit implementaci vhodných abstraktních (virtuálních) tříd.
Co představuje implementace (= vytvoření potomka) jaké abstraktní třídy, je uvedeno v následujícím seznamu:
\begin{enumerate}[leftmargin=5mm]
\item TOI $\implies$ implementace nového typu TOI
\item TOIParser $\implies$ parser implementace nového typu TOI
\item TOIPrinter $\implies$ printer implementace nového typu TOI
\item Layout $\implies$ implementace nového layoutu
\item LayoutFactory $\implies$ implementace nové továrny pro konkrétní layout
\item Format $\implies$ implementace formátu
\item FilterParser $\implies$ implementace parseru filtru (filtr je libovolný funktor typu function$<$bool(const TimeOrganizerIndividual\&)$>$)
\item TOOParser $\implies$ implementace parseru operace nad prvky z TO
\item TimeOrganizerOperation $\implies$ implementace operace nad prvky z TO
\end{enumerate}
\subsection{Časová a paměťová složitost}
Na závěr bych zmínil, že časová i paměťová složitost celého programu jsou O(velikost vstupu * počet operací).
\end{document}